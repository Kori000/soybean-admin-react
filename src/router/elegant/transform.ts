/* prettier-ignore */
/* eslint-disable */
// Generated by elegant-router
// Read more: https://github.com/mufeng889/elegant-router
// Vue auto route: https://github.com/soybeanjs/elegant-router
// 请不要手动修改此文件，否则会导致优雅路由无法正常工作
// 如果需要修改，请在优雅路由配置文件中进行修改
// 这是自动生成的文件，请不要手动修改


import type { RouteKey, RouteMap, RoutePath } from '@elegant-router/types';
import type { ElegantConstRoute } from '@soybean-react/vite-plugin-react-router';
import type { ReactElement } from 'react';
import type { RouteObject } from 'react-router-dom';

type LazyRouteComponent = Record<string, () => Promise<{ default: () => ReactElement }>>;

type RouteConfig = Pick<RouteObject, 'action' | 'caseSensitive' | 'loader' | 'shouldRevalidate'> & { config?: any };

type LazyRouteConfig = Record<string, () => Promise<RouteConfig>>;

const loadings = import.meta.glob(`/src/pages/**/loading.tsx`, { eager: true, import: 'default' });

/**
 * transform elegant const routes to react routes
 *
 * @param routes elegant const routes
 * @param layouts layout components
 * @param views view components
 */
export function transformElegantRoutesToReactRoutes(
  routes: ElegantConstRoute[],
  layouts: LazyRouteComponent,
  views: LazyRouteComponent,
  errors: LazyRouteComponent,
  configs: LazyRouteConfig
) {
  return routes.flatMap(route => transformElegantRouteToReactRoute(route, layouts, views, errors, configs));
}

/**
 * transform elegant route to react route
 *
 * @param route elegant const route
 * @param layouts layout components
 * @param views view components
 */
export function transformElegantRouteToReactRoute(
  route: ElegantConstRoute,
  layouts: LazyRouteComponent,
  views: LazyRouteComponent,
  errors: LazyRouteComponent,
  configs: LazyRouteConfig
): RouteObject {
  const ROUTE_DEGREE_SPLITTER = '_';

  function isRouteGroup(name: string) {
    const lastName = name.split(ROUTE_DEGREE_SPLITTER).at(-1);
    return lastName?.startsWith('(') && lastName?.endsWith(')');
  }

  const { children, matchedFiles, name, path } = route;

  function getComPonent(routeName: string) {
    if (matchedFiles[0]) {
      return layouts[matchedFiles[0]]();
    }

    if (!isRouteGroup(routeName) && matchedFiles[1]) {
      return views[matchedFiles[1]]();
    }

    return null;
  }

  // Get the error boundary component
  function getErrorComponent() {
    return matchedFiles[3] ? errors[matchedFiles[3]]() : null;
  }

  // Convert route config, simplifying the logic for actions, loader, etc.
   function convertConfig(m: RouteConfig) {
    const { action, config, loader, shouldRevalidate, ...rest } = m;
    return {
      ...rest,
      action, // always use action
      handle: config,
      loader, // always use loader
      shouldRevalidate
    };
  }

  // Get config for the route if available
  async function getConfig(index:boolean=false) {
    if(matchedFiles[0]&&matchedFiles[1]&&!index) return null

    if (configs?.[name]) {
      const config = await configs[name]();
      return convertConfig(config);
    }

    return null;
  }

  const loaderModule = [getComPonent(name), getErrorComponent()];

  const reactRoute = {
    children: [],
    HydrateFallback: matchedFiles[2] ? loadings[`/src/pages${matchedFiles[2]==='/root'?'':matchedFiles[2]}/loading.tsx`] : null,
    id: name,
    lazy: async () => {
      const [Component, ErrorBoundary] = await Promise.all(loaderModule);

      return {
        Component: Component?.default,
        ErrorBoundary: ErrorBoundary?.default,
        ...(await getConfig())
      };
    },
    path
  } as RouteObject;

  if (children?.length) {
    reactRoute.children = children.flatMap(child =>
      transformElegantRouteToReactRoute(child, layouts, views, errors, configs)
    );

    if (matchedFiles[0] && matchedFiles[1] && !isRouteGroup(name)) {
      reactRoute.children.unshift({
        index: true,
        lazy: async () => {
          const [Component, ErrorBoundary] = await Promise.all([matchedFiles[1]?views[matchedFiles[1]]():null, getErrorComponent()]);

          return {
            Component: Component?.default,
            ErrorBoundary: ErrorBoundary?.default,
            ...(await getConfig(true))
          };
        }
      });
    }
  }

  return reactRoute;
}


/**
 * map of route name and route path
 */
export const routeMap: RouteMap = {
  "not-found": "*",
  "exception": "/exception",
  "exception_403": "/exception/403",
  "exception_404": "/exception/404",
  "exception_500": "/exception/500",
  "document": "/document",
  "document_project": "/document/project",
  "document_project-link": "/document/project-link",
  "document_react": "/document/react",
  "document_vite": "/document/vite",
  "document_unocss": "/document/unocss",
  "document_procomponents": "/document/procomponents",
  "document_antd": "/document/antd",
  "logout": "/logout",
  "(base)_home": "/home",
  "(blank)_login": "/login",
  "(blank)_login_code-login": "/login/code-login",
  "(blank)_login_register": "/login/register",
  "(blank)_login_reset-pwd": "/login/reset-pwd",
  "403": "/403",
  "404": "/404",
  "500": "/500",
  "root": "/"
};

/**
 * get route path by route name
 * @param name route name
 */
export function getRoutePath<T extends RouteKey>(name: T) {
  return routeMap[name];
}

/**
 * get route name by route path
 * @param path route path
 */
export function getRouteName(path: RoutePath) {
  const routeEntries = Object.entries(routeMap) as [RouteKey, RoutePath][];

  const routeName: RouteKey | null = routeEntries.find(([, routePath]) => routePath === path)?.[0] || null;

  return routeName;
}

